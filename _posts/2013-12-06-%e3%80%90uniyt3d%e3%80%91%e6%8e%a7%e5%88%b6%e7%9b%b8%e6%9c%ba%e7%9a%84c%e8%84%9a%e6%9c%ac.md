---
title: '【Uniyt3D】控制相机的C#脚本'
author: admin
layout: post
permalink: /%e3%80%90uniyt3d%e3%80%91%e6%8e%a7%e5%88%b6%e7%9b%b8%e6%9c%ba%e7%9a%84c%e8%84%9a%e6%9c%ac/
categories:
  - Unity
tags:
  - Camera
---
<pre class="lang:c# decode:true ">using UnityEngine;
using System.Collections;

public class Move : MonoBehaviour {
	public Transform target;
	public float distance = 10.0f;
	public float xSpeed = 250.0f;
	public float ySpeed = 120.0f;
	public float yMinLimit = -20f;
	public float yMaxLimit = 80f;
	public float x = 0;
	public float y = 0;

	private Vector2 oldPosition1;
	private Vector2 oldPosition2;

	void Start () {
		var angles = transform.eulerAngles;
		x = angles.x;
		y = angles.y;
		if(rigidbody){
			rigidbody.freezeRotation = true;
		}

	}

	// Update is called once per frame
	void Update () {
		if(Input.touchCount == 1){
			if(Input.GetTouch(0).phase == TouchPhase.Moved){
				x += (float)(Input.GetAxis("Mouse X") * xSpeed * 0.02);
				y += (float)(Input.GetAxis("Mouse Y") * ySpeed * 0.02);
			}
		}
		if(Input.touchCount &gt; 1){
			if(Input.GetTouch(0).phase == TouchPhase.Moved || Input.GetTouch(1).phase == TouchPhase.Moved){
				Vector2 tempPosition1 = Input.GetTouch(0).position;
				Vector2 tempPosition2 = Input.GetTouch(1).position;
				if(isEnlarge(oldPosition1,oldPosition2,tempPosition1,tempPosition2)){
					if(distance &gt; 3){
						distance -= 0.5f;
					}
				}else{
					if(distance &lt; 18.5){
						distance += 0.5f;
					}
				}
				oldPosition1 = tempPosition1;
				oldPosition2 = tempPosition2;

			}
		}
	}

	bool isEnlarge(Vector2 oP1,Vector2 oP2,Vector2 nP1,Vector2 nP2){
		float leng1 =Mathf.Sqrt((oP1.x-oP2.x)*(oP1.x-oP2.x)+(oP1.y-oP2.y)*(oP1.y-oP2.y));
		float leng2 =Mathf.Sqrt((nP1.x-nP2.x)*(nP1.x-nP2.x)+(nP1.y-nP2.y)*(nP1.y-nP2.y));
		if(leng1 &gt; leng2){
			return false;
		}else{
			return true;
		}
	}

	void LateUpdate(){
		if(target){
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion rotation = Quaternion.Euler(y, x, 0);
			Vector3 position = rotation *(new Vector3(0.0f, 0.0f, -distance)) + target.position;

			transform.rotation = rotation;
			transform.position = position;
		}
	}
	static float ClampAngle(float angle,float min,float max){
		if (angle &lt; -360)
			angle += 360;
		if (angle &gt; 360)
			angle -= 360;
		return Mathf.Clamp (angle, min, max);
	}
}</pre>

&nbsp;