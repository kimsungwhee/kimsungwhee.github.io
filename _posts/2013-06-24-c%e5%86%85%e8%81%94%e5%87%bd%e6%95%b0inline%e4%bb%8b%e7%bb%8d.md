---
title: C++内联函数(Inline)介绍
author: admin
layout: post
permalink: /c%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0inline%e4%bb%8b%e7%bb%8d/
categories:
  - C++
tags:
  - C++
  - Inline
---
介绍内联函数之前，有必要介绍一下预处理宏。内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如

<pre class="lang:c++ decode:true ">#define TABLE_COMP(x) ((x)&gt;0?(x):0)</pre>

就定义了一个宏。

为什么要使用宏呢？因为函数的调用必须要将<a href="http://dev.yesky.com/" target="_blank">程序</a>执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。

但是宏也有很多的不尽人意的地方。

1、．宏不能访问对象的私有成员。

2、．宏的定义很容易产生二意性。

我们举个例子：

<pre class="lang:c++ decode:true ">#define TABLE_MULTI(x) (x*x)</pre>

我们用一个数字去调用它,TABLE\_MULTI(10)，这样看上去没有什么错误，结果返回100,是正确的，但是如果我们用TABLE\_MULTI(10+10)去调用的话，我们期望的结果是４００，而宏的调用结果是(10+10*10+10),结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号。

<pre class="lang:c++ decode:true ">#define TABLE_MULTI(x) ((x)*(x))</pre>

这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用TABLE_MULTI(a++)调用它，他们本意是希望得到(a+1)\*(a+1)的结果，而实际上呢？我们可以看看宏的展开结果: (a++)\*(a++)，如果a的值是４，我们得到的结果是5\*6=30。而我们期望的结果是5\*5=25,这又出现了问题。事实上，在一些C的库函数中也有这些问题。例如: Toupper(*pChar++)就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。

我们可以看到宏有一些难以避免的问题，怎么解决呢？

下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。

内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。

我们可以用Inline来定义内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。

下面我们来介绍一下内联函数的用法。

内联函数必须是和函数体申明在一起，才有效。像这样的申明Inline Tablefunction(int I)是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体。

<pre class="lang:c++ decode:true ">Inline tablefunction(int I) {return I*I};</pre>

这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。

我们也可以将定义在类的外部的函数定义为内联函数，比如：

<pre class="lang:c++ decode:true ">Class TableClass{
　Private:
　　Int I,j;
　Public: 
　　Int add() { return I+j;};
　　Inline int dec() { return I-j;}
　　Int GetNum();
}
inline int tableclass::GetNum(){
return I;
}</pre>

上面申明的三个函数都是内联函数。在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。

内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。

<pre class="lang:c++ decode:true ">Class sample{
　Private:
　　Int nTest;
　Public:
　　Int readtest(){ return nTest;}
　Void settest(int I) {nTest=I;}
}</pre>

当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。